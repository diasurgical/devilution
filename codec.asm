; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.9044.0 

	TITLE	Source/codec.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BK@BPIO@Invalid?5encode?5parameters?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC ''
CRT$XCU	ENDS
;	COMDAT @codec_decode@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @codec_init_key@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @codec_get_encoded_len@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @codec_encode@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	@codec_decode@12
PUBLIC	@codec_init_key@8
EXTRN	_SHA1Clear:NEAR
EXTRN	@SHA1Result@8:NEAR
EXTRN	@SHA1Calculate@12:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_memset:NEAR
; Function compile flags: /Ogsy
;	COMDAT @codec_decode@12
_TEXT	SEGMENT
_pszPassword$ = 8
_v5$ = -4
_v9$ = -152
_dst$ = -24
_passworda$ = 8
@codec_decode@12 PROC NEAR				; COMDAT
; _pbSrcDst$ = ecx
; _size$ = edx
; File Source/codec.cpp
; Line 6
	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	edi, edx
; Line 19
	mov	edx, DWORD PTR _pszPassword$[ebp]
	mov	esi, ecx
	xor	ecx, ecx
	call	@codec_init_key@8
; Line 20
	cmp	edi, 8
; Line 21
	jbe	SHORT $L85092
; Line 22
	lea	ebx, DWORD PTR [edi-8]
; Line 24
	test	bl, 63					; 0000003fH
	mov	DWORD PTR _v5$[ebp], ebx
	je	SHORT $L85000
$L85092:
; Line 25
	xor	eax, eax
	jmp	$L84988
$L85000:
; Line 27
	test	ebx, ebx
	mov	DWORD PTR _passworda$[ebp], ebx
	je	SHORT $L85002
	push	64					; 00000040H
	pop	edi
$L85003:
; Line 29
	push	edi
	lea	eax, DWORD PTR _v9$[ebp]
	push	esi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; Line 30
	lea	edx, DWORD PTR _dst$[ebp]
	xor	ecx, ecx
	call	@SHA1Result@8
; Line 31
	xor	ecx, ecx
$L85006:
; Line 33
	mov	eax, ecx
	push	20					; 00000014H
	cdq
	pop	ebx
	idiv	ebx
	mov	al, BYTE PTR _dst$[ebp+edx]
	xor	BYTE PTR _v9$[ebp+ecx], al
; Line 34
	inc	ecx
; Line 35
	cmp	ecx, edi
	jl	SHORT $L85006
; Line 36
	push	0
	lea	edx, DWORD PTR _v9$[ebp]
	xor	ecx, ecx
	call	@SHA1Calculate@12
; Line 37
	lea	eax, DWORD PTR _dst$[ebp]
	push	ebx
	push	0
	push	eax
	call	_memset
; Line 38
	lea	eax, DWORD PTR _v9$[ebp]
	push	edi
	push	eax
	push	esi
	call	_memcpy
	add	esp, 24					; 00000018H
; Line 39
	add	esi, edi
; Line 40
	sub	DWORD PTR _passworda$[ebp], edi
; Line 41
	jne	SHORT $L85003
	mov	ebx, DWORD PTR _v5$[ebp]
$L85002:
; Line 44
	push	128					; 00000080H
	lea	eax, DWORD PTR _v9$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; Line 45
	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $L85010
; Line 46
	lea	edx, DWORD PTR _dst$[ebp]
	xor	ecx, ecx
	call	@SHA1Result@8
; Line 47
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR _dst$[ebp]
	jne	SHORT $L85013
; Line 48
	movzx	eax, BYTE PTR [esi+5]
	lea	esi, DWORD PTR [eax+ebx-64]
; Line 49
	jmp	SHORT $LABEL_14$85015
$L85013:
; Line 51
	push	20					; 00000014H
	lea	eax, DWORD PTR _dst$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$L85010:
; Line 53
	xor	esi, esi
$LABEL_14$85015:
; Line 55
	call	_SHA1Clear
; Line 56
	mov	eax, esi
$L84988:
	pop	edi
	pop	esi
	pop	ebx
; Line 57
	leave
	ret	4
@codec_decode@12 ENDP
_TEXT	ENDS
EXTRN	_rand:NEAR
EXTRN	_srand:NEAR
EXTRN	@SHA1Reset@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT @codec_init_key@8
_TEXT	SEGMENT
_key$ = -224
_pw$ = -88
_digest$ = -24
@codec_init_key@8 PROC NEAR				; COMDAT
; _unused$ = ecx
; _pszPassword$ = edx
; Line 61
	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
; Line 68
	push	28760					; 00007058H
	mov	edi, edx
	call	_srand
	mov	ebx, 136				; 00000088H
	pop	ecx
; Line 70
	lea	esi, DWORD PTR _key$[ebp]
	mov	DWORD PTR -4+[ebp], ebx
$L85028:
; Line 72
	call	_rand
	mov	BYTE PTR [esi], al
; Line 73
	inc	esi
	dec	DWORD PTR -4+[ebp]
	jne	SHORT $L85028
; Line 75
	xor	eax, eax
; Line 76
	xor	ecx, ecx
$L85031:
; Line 77
	cmp	BYTE PTR [eax+edi], 0
	jne	SHORT $L85034
; Line 78
	xor	eax, eax
$L85034:
; Line 79
	mov	dl, BYTE PTR [eax+edi]
; Line 80
	inc	eax
	mov	BYTE PTR _pw$[ebp+ecx], dl
	inc	ecx
	cmp	ecx, 64					; 00000040H
	jl	SHORT $L85031
; Line 82
	xor	ecx, ecx
	call	@SHA1Reset@4
; Line 83
	lea	eax, DWORD PTR _digest$[ebp]
	lea	edx, DWORD PTR _pw$[ebp]
	push	eax
	xor	ecx, ecx
	call	@SHA1Calculate@12
; Line 84
	call	_SHA1Clear
; Line 85
	xor	edi, edi
	xor	ecx, ecx
$L85036:
; Line 86
	mov	eax, ecx
	push	20					; 00000014H
	cdq
	pop	esi
	idiv	esi
	mov	al, BYTE PTR _digest$[ebp+edx]
	xor	BYTE PTR _key$[ebp+ecx], al
	inc	ecx
	cmp	ecx, ebx
	jb	SHORT $L85036
; Line 87
	push	64					; 00000040H
	lea	eax, DWORD PTR _pw$[ebp]
	push	edi
	push	eax
	call	_memset
; Line 88
	push	esi
	lea	eax, DWORD PTR _digest$[ebp]
	push	edi
	push	eax
	call	_memset
	add	esp, 24					; 00000018H
; Line 89
	xor	esi, esi
$L85039:
; Line 90
	mov	ecx, esi
	call	@SHA1Reset@4
; Line 91
	lea	edx, DWORD PTR _key$[ebp+72]
	mov	ecx, esi
	push	edi
	call	@SHA1Calculate@12
	inc	esi
	cmp	esi, 3
	jl	SHORT $L85039
; Line 93
	push	ebx
	lea	eax, DWORD PTR _key$[ebp]
	push	edi
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
; Line 94
	leave
	ret	0
@codec_init_key@8 ENDP
_TEXT	ENDS
PUBLIC	@codec_get_encoded_len@4
; Function compile flags: /Ogsy
;	COMDAT @codec_get_encoded_len@4
_TEXT	SEGMENT
@codec_get_encoded_len@4 PROC NEAR			; COMDAT
; _dwSrcBytes$ = ecx
; Line 101
	mov	eax, ecx
	and	eax, 63					; 0000003fH
	je	SHORT $L85046
; Line 102
	push	64					; 00000040H
	pop	edx
	sub	edx, eax
	add	ecx, edx
$L85046:
; Line 103
	lea	eax, DWORD PTR [ecx+8]
; Line 104
	ret	0
@codec_get_encoded_len@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BPIO@Invalid?5encode?5parameters?$AA@	; `string'
PUBLIC	@codec_encode@16
EXTRN	_TermMsg:NEAR
;	COMDAT ??_C@_0BK@BPIO@Invalid?5encode?5parameters?$AA@
_DATA	SEGMENT
??_C@_0BK@BPIO@Invalid?5encode?5parameters?$AA@ DB 'Invalid encode parame'
	DB	'ters', 00H					; `string'
; Function compile flags: /Ogsy
_DATA	ENDS
;	COMDAT @codec_encode@16
_TEXT	SEGMENT
_size_64$ = 8
_pszPassword$ = 12
_v9$ = -172
_v10$ = -44
_dst$ = -24
_v12$ = -4
@codec_encode@16 PROC NEAR				; COMDAT
; _pbSrcDst$ = ecx
; _size$ = edx
; Line 107
	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx
; Line 119
	mov	ecx, edi
	mov	DWORD PTR _v12$[ebp], edi
	call	@codec_get_encoded_len@4
	cmp	DWORD PTR _size_64$[ebp], eax
	je	SHORT $L85065
; Line 120
	push	OFFSET FLAT:??_C@_0BK@BPIO@Invalid?5encode?5parameters?$AA@ ; `string'
	call	_TermMsg
	pop	ecx
$L85065:
; Line 121
	mov	edx, DWORD PTR _pszPassword$[ebp]
	xor	ecx, ecx
	inc	ecx
	call	@codec_init_key@8
; Line 122
	xor	bl, bl
; Line 123
	test	edi, edi
	je	$L85067
	push	64					; 00000040H
	pop	edi
$L85068:
; Line 125
	mov	ebx, DWORD PTR _v12$[ebp]
; Line 126
	cmp	ebx, edi
	jb	SHORT $L85071
; Line 127
	mov	ebx, edi
$L85071:
; Line 128
	push	ebx
	lea	eax, DWORD PTR _v9$[ebp]
	push	esi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; Line 129
	cmp	ebx, edi
	jae	SHORT $L85072
; Line 130
	sub	edi, ebx
	lea	eax, DWORD PTR _v9$[ebp+ebx]
	push	edi
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$L85072:
; Line 131
	lea	edx, DWORD PTR _dst$[ebp]
	xor	ecx, ecx
	call	@SHA1Result@8
; Line 132
	lea	edx, DWORD PTR _v9$[ebp]
	xor	ecx, ecx
	push	0
	call	@SHA1Calculate@12
; Line 133
	xor	ecx, ecx
$L85074:
; Line 135
	mov	eax, ecx
	push	20					; 00000014H
	cdq
	pop	edi
	idiv	edi
; Line 137
	push	64					; 00000040H
	pop	edi
	mov	al, BYTE PTR _dst$[ebp+edx]
	xor	BYTE PTR _v9$[ebp+ecx], al
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $L85074
; Line 138
	push	20					; 00000014H
	lea	eax, DWORD PTR _dst$[ebp]
	push	0
	push	eax
	call	_memset
; Line 139
	lea	eax, DWORD PTR _v9$[ebp]
	push	edi
	push	eax
	push	esi
	call	_memcpy
	add	esp, 24					; 00000018H
; Line 140
	add	esi, edi
; Line 141
	sub	DWORD PTR _v12$[ebp], ebx
; Line 142
	jne	$L85068
$L85067:
; Line 145
	push	128					; 00000080H
	lea	eax, DWORD PTR _v9$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; Line 146
	lea	edx, DWORD PTR _v10$[ebp]
	xor	ecx, ecx
	call	@SHA1Result@8
; Line 149
	mov	eax, DWORD PTR _v10$[ebp]
	and	BYTE PTR [esi+4], 0
	and	WORD PTR [esi+6], 0
	mov	DWORD PTR [esi], eax
; Line 150
	mov	BYTE PTR [esi+5], bl
; Line 151
	call	_SHA1Clear
	pop	edi
	pop	esi
	pop	ebx
; Line 152
	leave
	ret	8
@codec_encode@16 ENDP
_TEXT	ENDS
END
