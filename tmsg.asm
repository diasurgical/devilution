; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.9044.0 

	TITLE	Source/tmsg.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC ''
CRT$XCU	ENDS
;	COMDAT @tmsg_get@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @tmsg_add@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tmsg_cleanup
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	@tmsg_get@8
EXTRN	@mem_free_dbg@4:NEAR
EXTRN	__imp__GetTickCount@0:NEAR
EXTRN	_memcpy:NEAR
_BSS	SEGMENT
_sgpTimedMsgHead DD 01H DUP (?)
; Function compile flags: /Ogsy
_BSS	ENDS
;	COMDAT @tmsg_get@8
_TEXT	SEGMENT
@tmsg_get@8 PROC NEAR					; COMDAT
; _pbMsg$ = ecx
; _dwMaxLen$ = edx
; File Source/tmsg.cpp
; Line 12
	cmp	DWORD PTR _sgpTimedMsgHead, 0
	push	ebx
	push	esi
	mov	ebx, ecx
; Line 13
	je	SHORT $L85021
; Line 15
	call	DWORD PTR __imp__GetTickCount@0
	mov	esi, DWORD PTR _sgpTimedMsgHead
	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, eax
	js	SHORT $L84992
$L85021:
; Line 16
	xor	eax, eax
	jmp	SHORT $L84987
$L84992:
; Line 18
	mov	eax, DWORD PTR [esi]
	push	edi
	mov	DWORD PTR _sgpTimedMsgHead, eax
; Line 21
	lea	eax, DWORD PTR [esi+9]
	movzx	edi, BYTE PTR [esi+8]
	push	edi
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
; Line 22
	mov	ecx, esi
	call	@mem_free_dbg@4
; Line 23
	mov	eax, edi
	pop	edi
$L84987:
	pop	esi
	pop	ebx
; Line 24
	ret	0
@tmsg_get@8 ENDP
_TEXT	ENDS
PUBLIC	@tmsg_add@8
EXTRN	@DiabloAllocPtr@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT @tmsg_add@8
_TEXT	SEGMENT
@tmsg_add@8 PROC NEAR					; COMDAT
; _pbMsg$ = ecx
; _bLen$ = dl
; Line 27
	push	ebx
	push	ebp
	push	esi
	mov	bl, dl
	push	edi
	mov	ebp, ecx
; Line 30
	movzx	edi, bl
	lea	ecx, DWORD PTR [edi+12]
	call	@DiabloAllocPtr@4
	mov	esi, eax
; Line 31
	and	DWORD PTR [esi], 0
; Line 32
	call	DWORD PTR __imp__GetTickCount@0
	add	eax, 500				; 000001f4H
; Line 33
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR [esi+4], eax
; Line 34
	push	edi
	lea	eax, DWORD PTR [esi+9]
	push	ebp
	push	eax
	call	_memcpy
; Line 35
	mov	ecx, DWORD PTR _sgpTimedMsgHead
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET FLAT:_sgpTimedMsgHead
	jmp	SHORT $L85027
$L85002:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
$L85027:
	test	ecx, ecx
	jne	SHORT $L85002
; Line 38
	mov	DWORD PTR [eax], esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; Line 39
	ret	0
@tmsg_add@8 ENDP
_TEXT	ENDS
PUBLIC	_tmsg_cleanup
; Function compile flags: /Ogsy
;	COMDAT _tmsg_cleanup
_TEXT	SEGMENT
_tmsg_cleanup PROC NEAR					; COMDAT
; Line 43
	mov	eax, DWORD PTR _sgpTimedMsgHead
	test	eax, eax
	je	SHORT $L85008
	push	esi
$L85007:
; Line 44
	mov	esi, DWORD PTR [eax]
; Line 46
	and	DWORD PTR _sgpTimedMsgHead, 0
; Line 47
	mov	ecx, eax
	call	@mem_free_dbg@4
; Line 48
	mov	eax, esi
	test	esi, esi
	mov	DWORD PTR _sgpTimedMsgHead, eax
	jne	SHORT $L85007
	pop	esi
$L85008:
; Line 51
	ret	0
_tmsg_cleanup ENDP
_TEXT	ENDS
END
