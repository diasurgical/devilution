; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.9044.0 

	TITLE	Source/path.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC ''
CRT$XCU	ENDS
;	COMDAT @FindPath@28
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_get_h_cost@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_check_equal@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _GetNextPath
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_solid_pieces@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_get_path@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_parent_path@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_get_node1@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_get_node2@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_next_node@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_set_coords@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @path_push_active_step@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _path_pop_active_step
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _path_new_step
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_pathxdir
PUBLIC	_pathydir
PUBLIC	_path_directions
_DATA	SEGMENT
COMM	_path_nodes:BYTE:03cf0H
COMM	_gdwCurPathStep:DWORD
COMM	_gdwCurNodes:DWORD
COMM	_pnode_vals:DWORD:019H
COMM	_pnode_ptr:DWORD
COMM	_pnode_tblptr:DWORD:012cH
COMM	_path_2_nodes:DWORD
_DATA	ENDS
CONST	SEGMENT
_pathxdir DB	0ffH
	DB	0ffH
	DB	01H
	DB	01H
	DB	0ffH
	DB	00H
	DB	01H
	DB	00H
_pathydir DB	0ffH
	DB	01H
	DB	0ffH
	DB	01H
	DB	00H
	DB	0ffH
	DB	00H
	DB	01H
CONST	ENDS
_DATA	SEGMENT
_path_directions DB 05H
	DB	01H
	DB	06H
	DB	02H
	DB	00H
	DB	03H
	DB	08H
	DB	04H
	DB	07H
_DATA	ENDS
PUBLIC	@FindPath@28
PUBLIC	@path_get_h_cost@16
PUBLIC	_GetNextPath
PUBLIC	@path_get_path@20
PUBLIC	_path_new_step
; Function compile flags: /Ogsy
;	COMDAT @FindPath@28
_TEXT	SEGMENT
_PosOk$ = -8
_PosOkArg$ = -4
_sx$ = 8
_sy$ = 12
_dx$ = 16
_dy$ = 20
_path$ = 24
@FindPath@28 PROC NEAR					; COMDAT
; _PosOk$ = ecx
; _PosOkArg$ = edx
; File Source/path.cpp
; Line 43
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
; Line 56
	and	DWORD PTR _gdwCurNodes, 0
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _PosOkArg$[ebp], edx
	mov	DWORD PTR _PosOk$[ebp], ecx
; Line 57
	call	_path_new_step
; Line 58
	and	DWORD PTR _gdwCurPathStep, 0
	mov	DWORD PTR _path_2_nodes, eax
; Line 59
	call	_path_new_step
	mov	DWORD PTR _pnode_ptr, eax
; Line 60
	call	_path_new_step
; Line 62
	push	DWORD PTR _dy$[ebp]
	mov	edi, DWORD PTR _sy$[ebp]
	mov	ebx, DWORD PTR _sx$[ebp]
	mov	esi, eax
	push	DWORD PTR _dx$[ebp]
	mov	edx, edi
	and	BYTE PTR [esi+2], 0
	mov	ecx, ebx
	call	@path_get_h_cost@16
; Line 65
	mov	cl, BYTE PTR [esi+2]
	mov	BYTE PTR [esi+1], al
	add	cl, al
	mov	DWORD PTR [esi+4], ebx
	mov	BYTE PTR [esi], cl
; Line 66
	mov	DWORD PTR [esi+8], edi
; Line 67
	mov	eax, DWORD PTR _path_2_nodes
	mov	DWORD PTR [eax+48], esi
$L85011:
; Line 70
	call	_GetNextPath
; Line 72
	test	eax, eax
	je	SHORT $L85219
; Line 75
	mov	ecx, DWORD PTR _dx$[ebp]
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $L85014
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR _dy$[ebp]
	je	SHORT $L85012
$L85014:
; Line 78
	push	DWORD PTR _dy$[ebp]
	mov	edx, DWORD PTR _PosOkArg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _PosOk$[ebp]
	push	eax
	call	@path_get_path@20
	test	eax, eax
	jne	SHORT $L85011
; Line 69
	jmp	SHORT $L85219
$L85012:
; Line 82
	lea	esi, DWORD PTR [eax+12]
; Line 83
	xor	ebx, ebx
	mov	edx, eax
; Line 84
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $L85022
	mov	edi, OFFSET FLAT:_pnode_vals
	sub	edi, 4
$L85018:
; Line 86
	cmp	ebx, 25					; 00000019H
	sete	al
; Line 87
	cmp	edi, OFFSET FLAT:_pnode_vals+96
	jge	SHORT $L85019
; Line 89
	mov	eax, DWORD PTR [edx+8]
	add	edi, 4
	sub	eax, DWORD PTR [ecx+8]
	inc	ebx
	lea	eax, DWORD PTR [eax+eax*2]
	sub	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+4]
	movsx	eax, BYTE PTR _path_directions[eax+ecx+4]
	mov	DWORD PTR [edi], eax
; Line 90
	mov	edx, DWORD PTR [esi]
; Line 91
	lea	esi, DWORD PTR [edx+12]
; Line 92
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $L85018
; Line 93
	cmp	ebx, 25					; 00000019H
	sete	al
$L85019:
; Line 97
	test	al, al
	je	SHORT $L85022
$L85219:
; Line 98
	xor	eax, eax
	jmp	SHORT $L84999
$L85022:
; Line 100
	xor	eax, eax
; Line 101
	test	ebx, ebx
	jle	SHORT $L84999
; Line 102
	lea	edx, DWORD PTR _pnode_vals[ebx*4-4]
$L85024:
; Line 106
	mov	esi, DWORD PTR _path$[ebp]
	mov	cl, BYTE PTR [edx]
	sub	edx, 4
	mov	BYTE PTR [eax+esi], cl
	inc	eax
; Line 107
	cmp	eax, ebx
	jl	SHORT $L85024
$L84999:
	pop	edi
	pop	esi
	pop	ebx
; Line 110
	leave
	ret	20					; 00000014H
@FindPath@28 ENDP
_TEXT	ENDS
EXTRN	_abs:NEAR
; Function compile flags: /Ogsy
;	COMDAT @path_get_h_cost@16
_TEXT	SEGMENT
_dx$ = 8
_dy$ = 12
@path_get_h_cost@16 PROC NEAR				; COMDAT
; _sx$ = ecx
; _sy$ = edx
; Line 115
	sub	ecx, DWORD PTR _dx$[esp-4]
	push	esi
	push	edi
	mov	esi, edx
	push	ecx
	call	_abs
; Line 116
	sub	esi, DWORD PTR _dy$[esp+8]
	mov	edi, eax
	push	esi
	call	_abs
	pop	ecx
; Line 118
	cmp	edi, eax
	pop	ecx
	mov	ecx, edi
	jl	SHORT $L85229
	mov	ecx, eax
; Line 119
	jle	SHORT $L85229
	mov	eax, edi
$L85229:
; Line 122
	add	eax, ecx
	pop	edi
	add	eax, eax
	pop	esi
; Line 123
	ret	8
@path_get_h_cost@16 ENDP
_TEXT	ENDS
PUBLIC	@path_check_equal@12
; Function compile flags: /Ogsy
;	COMDAT @path_check_equal@12
_TEXT	SEGMENT
_dy$ = 8
@path_check_equal@12 PROC NEAR				; COMDAT
; _pPath$ = ecx
; _dx$ = edx
; Line 133
	cmp	DWORD PTR [ecx+4], edx
	je	SHORT $L85049
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR _dy$[esp-4]
	je	SHORT $L85049
; Line 136
	push	3
	jmp	SHORT $L85234
$L85049:
; Line 134
	push	2
$L85234:
	pop	eax
; Line 137
	ret	4
@path_check_equal@12 ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT _GetNextPath
_TEXT	SEGMENT
_GetNextPath PROC NEAR					; COMDAT
; Line 146
	mov	ecx, DWORD PTR _path_2_nodes
	mov	eax, DWORD PTR [ecx+48]
; Line 147
	test	eax, eax
	jne	SHORT $L85053
; Line 155
	ret	0
$L85053:
; Line 151
	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx+48], edx
; Line 152
	mov	ecx, DWORD PTR _pnode_ptr
	mov	ecx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], ecx
; Line 153
	mov	ecx, DWORD PTR _pnode_ptr
	mov	DWORD PTR [ecx+48], eax
; Line 155
	ret	0
_GetNextPath ENDP
_TEXT	ENDS
PUBLIC	@path_solid_pieces@12
EXTRN	_dPiece:BYTE
EXTRN	_nSolidTable:BYTE
; Function compile flags: /Ogsy
;	COMDAT @path_solid_pieces@12
_TEXT	SEGMENT
_dy$ = 8
@path_solid_pieces@12 PROC NEAR				; COMDAT
; _pPath$ = ecx
; _dx$ = edx
; Line 166
	push	esi
	push	edi
; Line 168
	mov	edi, DWORD PTR _dy$[esp+4]
	xor	eax, eax
	mov	esi, edi
	inc	eax
	sub	esi, DWORD PTR [ecx+8]
	lea	esi, DWORD PTR [esi+esi*2]
	sub	esi, DWORD PTR [ecx+4]
	movsx	ecx, BYTE PTR _path_directions[esi+edx+4]
	sub	ecx, 5
	je	SHORT $L85066
	dec	ecx
	je	SHORT $L85067
	dec	ecx
	je	SHORT $L85068
	dec	ecx
	jne	SHORT $L85242
; Line 179
	imul	edx, 112				; 00000070H
	add	edx, edi
	xor	eax, eax
	shl	edx, 2
	mov	ecx, DWORD PTR _dPiece[edx+448]
	cmp	BYTE PTR _nSolidTable[ecx], al
	jne	SHORT $L85242
	mov	ecx, DWORD PTR _dPiece[edx-4]
	jmp	SHORT $L85249
$L85068:
; Line 176
	imul	edx, 112				; 00000070H
	lea	ecx, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR _dPiece[ecx*4-4]
	jmp	SHORT $L85250
$L85067:
; Line 173
	imul	edx, 112				; 00000070H
	lea	ecx, DWORD PTR [edx+edi]
	mov	edx, DWORD PTR _dPiece[ecx*4+4]
$L85250:
	xor	eax, eax
	cmp	BYTE PTR _nSolidTable[edx], al
	jne	SHORT $L85242
	mov	ecx, DWORD PTR _dPiece[ecx*4-448]
	jmp	SHORT $L85249
$L85066:
; Line 170
	imul	edx, 112				; 00000070H
	add	edx, edi
	xor	eax, eax
	shl	edx, 2
	mov	ecx, DWORD PTR _dPiece[edx+4]
	cmp	BYTE PTR _nSolidTable[ecx], al
	jne	SHORT $L85242
	mov	ecx, DWORD PTR _dPiece[edx+448]
$L85249:
	cmp	BYTE PTR _nSolidTable[ecx], al
	jne	SHORT $L85242
	xor	eax, eax
	inc	eax
$L85242:
	pop	edi
	pop	esi
; Line 183
	ret	4
@path_solid_pieces@12 ENDP
_TEXT	ENDS
PUBLIC	@path_parent_path@20
; Function compile flags: /Ogsy
;	COMDAT @path_get_path@20
_TEXT	SEGMENT
_PosOk$ = -12
_PosOkArg$ = -8
_pPath$ = 8
_x$ = 12
_y$ = 16
_i$ = -4
@path_get_path@20 PROC NEAR				; COMDAT
; _PosOk$ = ecx
; _PosOkArg$ = edx
; Line 191
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
; Line 196
	mov	ebx, DWORD PTR _pPath$[ebp]
	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _PosOkArg$[ebp], edx
	mov	DWORD PTR _PosOk$[ebp], ecx
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L85088
$L85258:
	mov	eax, DWORD PTR _i$[ebp]
$L85088:
; Line 197
	movsx	esi, BYTE PTR _pathxdir[eax]
; Line 198
	movsx	edi, BYTE PTR _pathydir[eax]
	add	esi, DWORD PTR [ebx+4]
	add	edi, DWORD PTR [ebx+8]
; Line 199
	mov	ecx, DWORD PTR _PosOkArg$[ebp]
	push	edi
	mov	edx, esi
	call	DWORD PTR _PosOk$[ebp]
; Line 200
	test	eax, eax
	je	SHORT $L85257
	push	edi
	mov	edx, esi
	mov	ecx, ebx
	call	@path_solid_pieces@12
	test	eax, eax
	jne	SHORT $L85092
	jmp	SHORT $L85089
$L85257:
	cmp	esi, DWORD PTR _x$[ebp]
	jne	SHORT $L85089
	cmp	edi, DWORD PTR _y$[ebp]
	jne	SHORT $L85089
$L85092:
; Line 201
	push	DWORD PTR _y$[ebp]
	mov	edx, esi
	mov	ecx, ebx
	push	DWORD PTR _x$[ebp]
	push	edi
	call	@path_parent_path@20
	test	eax, eax
	je	SHORT $L85255
$L85089:
; Line 196
	inc	DWORD PTR _i$[ebp]
	cmp	DWORD PTR _i$[ebp], 8
	jl	SHORT $L85258
; Line 206
	xor	eax, eax
	inc	eax
$L85083:
	pop	edi
	pop	esi
	pop	ebx
; Line 207
	leave
	ret	12					; 0000000cH
$L85255:
; Line 202
	xor	eax, eax
	jmp	SHORT $L85083
@path_get_path@20 ENDP
_TEXT	ENDS
PUBLIC	@path_get_node1@8
PUBLIC	@path_get_node2@8
PUBLIC	@path_next_node@4
PUBLIC	@path_set_coords@4
; Function compile flags: /Ogsy
;	COMDAT @path_parent_path@20
_TEXT	SEGMENT
_dx$ = -4
_dy$ = 8
_sx$ = 12
_sy$ = 16
@path_parent_path@20 PROC NEAR				; COMDAT
; _pPath$ = ecx
; _dx$ = edx
; Line 215
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _dx$[ebp], edx
; Line 220
	push	DWORD PTR _dy$[ebp]
	mov	edi, ecx
	call	@path_check_equal@12
; Line 224
	mov	edx, DWORD PTR _dy$[ebp]
	mov	ecx, DWORD PTR _dx$[ebp]
	mov	ebx, eax
	movsx	eax, BYTE PTR [edi+2]
	add	ebx, eax
	call	@path_get_node1@8
	mov	esi, eax
; Line 225
	test	esi, esi
	je	SHORT $L85110
; Line 226
	xor	eax, eax
	lea	ecx, DWORD PTR [edi+16]
$L85111:
; Line 227
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L85265
	inc	eax
	add	ecx, 4
	cmp	eax, 8
	jl	SHORT $L85111
$L85265:
; Line 230
	mov	DWORD PTR [edi+eax*4+16], esi
; Line 231
	movsx	eax, BYTE PTR [esi+2]
	cmp	ebx, eax
	jge	$L85127
; Line 232
	push	DWORD PTR _dy$[ebp]
	mov	edx, DWORD PTR _dx$[ebp]
	mov	ecx, edi
	call	@path_solid_pieces@12
	test	eax, eax
	je	$L85127
; Line 236
	mov	al, BYTE PTR [esi+1]
	mov	DWORD PTR [esi+12], edi
	add	al, bl
	mov	BYTE PTR [esi+2], bl
	mov	BYTE PTR [esi], al
; Line 239
	jmp	$L85127
$L85110:
; Line 241
	mov	edx, DWORD PTR _dy$[ebp]
	mov	ecx, DWORD PTR _dx$[ebp]
	call	@path_get_node2@8
	mov	esi, eax
; Line 242
	test	esi, esi
	je	SHORT $L85120
; Line 243
	xor	eax, eax
	lea	ecx, DWORD PTR [edi+16]
$L85121:
; Line 244
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L85266
	inc	eax
	add	ecx, 4
	cmp	eax, 8
	jl	SHORT $L85121
$L85266:
; Line 247
	mov	DWORD PTR [edi+eax*4+16], esi
; Line 248
	movsx	eax, BYTE PTR [esi+2]
	cmp	ebx, eax
	jge	SHORT $L85127
	push	DWORD PTR _dy$[ebp]
	mov	edx, DWORD PTR _dx$[ebp]
	mov	ecx, edi
	call	@path_solid_pieces@12
	test	eax, eax
	je	SHORT $L85127
; Line 252
	mov	al, BYTE PTR [esi+1]
; Line 254
	mov	ecx, esi
	add	al, bl
	mov	DWORD PTR [esi+12], edi
	mov	BYTE PTR [esi+2], bl
	mov	BYTE PTR [esi], al
	call	@path_set_coords@4
; Line 256
	jmp	SHORT $L85127
$L85120:
; Line 258
	call	_path_new_step
	mov	esi, eax
; Line 259
	test	esi, esi
	je	SHORT $L85105
$L85129:
; Line 263
	push	DWORD PTR _sy$[ebp]
	mov	edx, DWORD PTR _dy$[ebp]
	mov	ecx, DWORD PTR _dx$[ebp]
	mov	DWORD PTR [esi+12], edi
	push	DWORD PTR _sx$[ebp]
	mov	BYTE PTR [esi+2], bl
	call	@path_get_h_cost@16
	mov	BYTE PTR [esi+1], al
; Line 264
	add	al, bl
	mov	BYTE PTR [esi], al
; Line 265
	mov	eax, DWORD PTR _dx$[ebp]
	mov	DWORD PTR [esi+4], eax
; Line 266
	mov	eax, DWORD PTR _dy$[ebp]
; Line 268
	mov	ecx, esi
	mov	DWORD PTR [esi+8], eax
	call	@path_next_node@4
; Line 270
	xor	ecx, ecx
	lea	eax, DWORD PTR [edi+16]
$L85130:
; Line 271
	cmp	DWORD PTR [eax], 0
	je	SHORT $L85267
	inc	ecx
	add	eax, 4
	cmp	ecx, 8
	jl	SHORT $L85130
$L85267:
; Line 274
	mov	DWORD PTR [edi+ecx*4+16], esi
$L85127:
; Line 277
	xor	eax, eax
	inc	eax
$L85105:
	pop	edi
	pop	esi
	pop	ebx
; Line 278
	leave
	ret	12					; 0000000cH
@path_parent_path@20 ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT @path_get_node1@8
_TEXT	SEGMENT
@path_get_node1@8 PROC NEAR				; COMDAT
; _dx$ = ecx
; _dy$ = edx
; Line 283
	mov	eax, DWORD PTR _path_2_nodes
	jmp	SHORT $L85275
$L85143:
; Line 284
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $L85145
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $L85144
$L85145:
; Line 285
	mov	eax, DWORD PTR [eax+48]
$L85275:
; Line 284
	test	eax, eax
	jne	SHORT $L85143
$L85144:
; Line 287
	ret	0
@path_get_node1@8 ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT @path_get_node2@8
_TEXT	SEGMENT
@path_get_node2@8 PROC NEAR				; COMDAT
; _dx$ = ecx
; _dy$ = edx
; Line 292
	mov	eax, DWORD PTR _pnode_ptr
	jmp	SHORT $L85281
$L85154:
; Line 293
	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $L85156
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $L85155
$L85156:
; Line 294
	mov	eax, DWORD PTR [eax+48]
$L85281:
; Line 293
	test	eax, eax
	jne	SHORT $L85154
$L85155:
; Line 296
	ret	0
@path_get_node2@8 ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT @path_next_node@4
_TEXT	SEGMENT
@path_next_node@4 PROC NEAR				; COMDAT
; _pPath$ = ecx
; Line 305
	mov	eax, DWORD PTR _path_2_nodes
	push	esi
	mov	esi, eax
; Line 306
	mov	eax, DWORD PTR [eax+48]
; Line 307
	test	eax, eax
	je	SHORT $L85163
	mov	dl, BYTE PTR [ecx]
$L85164:
; Line 309
	cmp	BYTE PTR [eax], dl
	jge	SHORT $L85166
; Line 311
	mov	esi, eax
; Line 312
	mov	eax, DWORD PTR [eax+48]
; Line 313
	test	eax, eax
	jne	SHORT $L85164
$L85166:
; Line 314
	mov	DWORD PTR [ecx+48], eax
$L85163:
; Line 316
	mov	DWORD PTR [esi+48], ecx
	pop	esi
; Line 317
	ret	0
@path_next_node@4 ENDP
_TEXT	ENDS
PUBLIC	@path_push_active_step@4
PUBLIC	_path_pop_active_step
; Function compile flags: /Ogsy
;	COMDAT @path_set_coords@4
_TEXT	SEGMENT
_i$ = -8
@path_set_coords@4 PROC NEAR				; COMDAT
; _pPath$ = ecx
; Line 321
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
; Line 326
	call	@path_push_active_step@4
; Line 327
	cmp	DWORD PTR _gdwCurPathStep, 0
	je	$L85177
	push	ebx
	push	esi
	push	edi
$L85176:
; Line 328
	call	_path_pop_active_step
; Line 329
	and	DWORD PTR _i$[ebp], 0
	mov	edi, eax
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR -4+[ebp], eax
$L85178:
; Line 330
	mov	eax, DWORD PTR -4+[ebp]
	mov	esi, DWORD PTR [eax]
; Line 331
	test	esi, esi
	je	SHORT $L85292
; Line 334
	mov	ebx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	ebx
	mov	ecx, edi
	call	@path_check_equal@12
	movsx	ecx, BYTE PTR [edi+2]
	add	eax, ecx
	movsx	ecx, BYTE PTR [esi+2]
	cmp	eax, ecx
	jge	SHORT $L85179
; Line 335
	push	ebx
	mov	ecx, edi
	call	@path_solid_pieces@12
	test	eax, eax
	je	SHORT $L85179
; Line 337
	mov	edx, DWORD PTR [esi+4]
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR [esi+12], edi
	call	@path_check_equal@12
	add	al, BYTE PTR [edi+2]
; Line 338
	mov	cl, BYTE PTR [esi+1]
	add	cl, al
	mov	BYTE PTR [esi+2], al
	mov	BYTE PTR [esi], cl
; Line 339
	mov	ecx, esi
	call	@path_push_active_step@4
$L85179:
	inc	DWORD PTR _i$[ebp]
	add	DWORD PTR -4+[ebp], 4
	cmp	DWORD PTR _i$[ebp], 8
	jl	SHORT $L85178
$L85292:
; Line 327
	cmp	DWORD PTR _gdwCurPathStep, 0
	jne	SHORT $L85176
	pop	edi
	pop	esi
	pop	ebx
$L85177:
; Line 344
	leave
	ret	0
@path_set_coords@4 ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT @path_push_active_step@4
_TEXT	SEGMENT
@path_push_active_step@4 PROC NEAR			; COMDAT
; _pPath$ = ecx
; Line 349
	mov	eax, DWORD PTR _gdwCurPathStep
; Line 350
	inc	DWORD PTR _gdwCurPathStep
; Line 351
	mov	DWORD PTR _pnode_tblptr[eax*4], ecx
; Line 352
	ret	0
@path_push_active_step@4 ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT _path_pop_active_step
_TEXT	SEGMENT
_path_pop_active_step PROC NEAR				; COMDAT
; Line 357
	dec	DWORD PTR _gdwCurPathStep
; Line 358
	mov	eax, DWORD PTR _gdwCurPathStep
	mov	eax, DWORD PTR _pnode_tblptr[eax*4]
; Line 359
	ret	0
_path_pop_active_step ENDP
_TEXT	ENDS
EXTRN	_memset:NEAR
; Function compile flags: /Ogsy
;	COMDAT _path_new_step
_TEXT	SEGMENT
_path_new_step PROC NEAR				; COMDAT
; Line 367
	cmp	DWORD PTR _gdwCurNodes, 300		; 0000012cH
	jne	SHORT $L85192
; Line 368
	xor	eax, eax
; Line 374
	ret	0
$L85192:
	push	esi
; Line 370
	mov	esi, DWORD PTR _gdwCurNodes
	imul	esi, 52					; 00000034H
	add	esi, OFFSET FLAT:_path_nodes
; Line 371
	inc	DWORD PTR _gdwCurNodes
; Line 372
	push	52					; 00000034H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
; Line 373
	mov	eax, esi
	pop	esi
; Line 374
	ret	0
_path_new_step ENDP
_TEXT	ENDS
END
