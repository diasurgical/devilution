; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.9044.0 

	TITLE	Source/encrypt.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC ''
CRT$XCU	ENDS
;	COMDAT @Decrypt@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @Encrypt@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @Hash@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InitHash
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @PkwareCompress@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PkwareBufferRead
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PkwareBufferWrite
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT @PkwareDecompress@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_hashtable:DWORD:0500H
_DATA	ENDS
PUBLIC	@Decrypt@12
; Function compile flags: /Ogsy
;	COMDAT @Decrypt@12
_TEXT	SEGMENT
_key$ = 8
@Decrypt@12 PROC NEAR					; COMDAT
; _block$ = ecx
; _size$ = edx
; File Source/encrypt.cpp
; Line 14
	shr	edx, 2
	mov	eax, -286331154				; eeeeeeeeH
	je	SHORT $L84995
	push	esi
	push	edi
	mov	edi, edx
	mov	edx, DWORD PTR _key$[esp+4]
$L84993:
; Line 15
	mov	esi, edx
	and	esi, 255				; 000000ffH
	add	eax, DWORD PTR _hashtable[esi*4+4096]
; Line 16
	lea	esi, DWORD PTR [eax+edx]
; Line 17
	imul	eax, 33					; 00000021H
	xor	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [ecx]
; Line 19
	add	ecx, 4
	lea	eax, DWORD PTR [eax+esi+3]
	mov	esi, edx
	not	esi
	shl	esi, 21					; 00000015H
	add	esi, 286331153				; 11111111H
	shr	edx, 11					; 0000000bH
	or	edx, esi
	dec	edi
	jne	SHORT $L84993
	pop	edi
	pop	esi
$L84995:
; Line 21
	ret	4
@Decrypt@12 ENDP
_TEXT	ENDS
PUBLIC	@Encrypt@12
; Function compile flags: /Ogsy
;	COMDAT @Encrypt@12
_TEXT	SEGMENT
_key$ = 8
@Encrypt@12 PROC NEAR					; COMDAT
; _block$ = ecx
; _size$ = edx
; Line 30
	shr	edx, 2
	mov	eax, -286331154				; eeeeeeeeH
	je	SHORT $L85010
	push	ebx
	push	esi
	push	edi
	mov	edi, edx
	mov	edx, DWORD PTR _key$[esp+8]
$L85008:
; Line 32
	mov	ebx, edx
	mov	esi, DWORD PTR [ecx]
	and	ebx, 255				; 000000ffH
	add	eax, DWORD PTR _hashtable[ebx*4+4096]
; Line 33
	lea	ebx, DWORD PTR [eax+edx]
; Line 34
	imul	eax, 33					; 00000021H
	xor	ebx, esi
	lea	eax, DWORD PTR [eax+esi+3]
; Line 35
	mov	esi, edx
	mov	DWORD PTR [ecx], ebx
	not	esi
	shl	esi, 21					; 00000015H
	add	esi, 286331153				; 11111111H
; Line 36
	add	ecx, 4
	shr	edx, 11					; 0000000bH
	or	edx, esi
	dec	edi
	jne	SHORT $L85008
	pop	edi
	pop	esi
	pop	ebx
$L85010:
; Line 38
	ret	4
@Encrypt@12 ENDP
_TEXT	ENDS
PUBLIC	@Hash@8
EXTRN	_toupper:NEAR
; Function compile flags: /Ogsy
;	COMDAT @Hash@8
_TEXT	SEGMENT
@Hash@8	PROC NEAR					; COMDAT
; _s$ = ecx
; _type$ = edx
; Line 41
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, edx
	mov	ebx, ecx
; Line 45
	mov	esi, 2146271213				; 7fed7fedH
; Line 46
	mov	edi, -286331154				; eeeeeeeeH
	jmp	SHORT $L85112
$L85021:
; Line 47
	mov	al, BYTE PTR [ebx]
	test	al, al
	je	SHORT $L85022
; Line 49
	movsx	eax, al
	push	eax
	inc	ebx
	call	_toupper
	pop	ecx
; Line 50
	lea	edx, DWORD PTR [edi+esi]
; Line 51
	imul	edi, 33					; 00000021H
	movsx	eax, al
	mov	ecx, ebp
	shl	ecx, 8
	add	ecx, eax
	mov	esi, DWORD PTR _hashtable[ecx*4]
	xor	esi, edx
	add	edi, eax
	lea	edi, DWORD PTR [edi+esi+3]
$L85112:
; Line 47
	test	ebx, ebx
	jne	SHORT $L85021
$L85022:
; Line 53
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; Line 54
	ret	0
@Hash@8	ENDP
_TEXT	ENDS
PUBLIC	_InitHash
; Function compile flags: /Ogsy
;	COMDAT _InitHash
_TEXT	SEGMENT
_InitHash PROC NEAR					; COMDAT
; Line 57
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
; Line 61
	mov	eax, 1048577				; 00100001H
	mov	DWORD PTR -4+[ebp], OFFSET FLAT:_hashtable
	mov	esi, 65535				; 0000ffffH
$L85028:
; Line 64
	mov	edi, DWORD PTR -4+[ebp]
	mov	DWORD PTR -8+[ebp], 5
$L85031:
; Line 65
	imul	eax, 125				; 0000007dH
	add	eax, 3
	xor	edx, edx
	mov	ecx, 2796203				; 002aaaabH
; Line 67
	mov	ebx, 2796203				; 002aaaabH
	div	ecx
	mov	eax, edx
	xor	edx, edx
	mov	ecx, eax
	imul	eax, 125				; 0000007dH
	add	eax, 3
	and	ecx, esi
	div	ebx
; Line 68
	shl	ecx, 16					; 00000010H
	mov	eax, edx
	and	edx, esi
	or	ecx, edx
	mov	DWORD PTR [edi], ecx
	add	edi, 1024				; 00000400H
	dec	DWORD PTR -8+[ebp]
	jne	SHORT $L85031
	add	DWORD PTR -4+[ebp], 4
	cmp	DWORD PTR -4+[ebp], OFFSET FLAT:_hashtable+1024
	jl	SHORT $L85028
	pop	edi
	pop	esi
	pop	ebx
; Line 71
	leave
	ret	0
_InitHash ENDP
_TEXT	ENDS
PUBLIC	@PkwareCompress@8
PUBLIC	_PkwareBufferRead
PUBLIC	_PkwareBufferWrite
EXTRN	_implode:NEAR
EXTRN	@DiabloAllocPtr@4:NEAR
EXTRN	@mem_free_dbg@4:NEAR
EXTRN	_memcpy:NEAR
; Function compile flags: /Ogsy
;	COMDAT @PkwareCompress@8
_TEXT	SEGMENT
_ptr$ = -4
_type$ = -12
_dsize$ = -8
_param$ = -32
@PkwareCompress@8 PROC NEAR				; COMDAT
; _buf$ = ecx
; _size$ = edx
; Line 74
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
; Line 81
	mov	ecx, 36312				; 00008dd8H
	mov	esi, edx
	call	@DiabloAllocPtr@4
	mov	DWORD PTR _ptr$[ebp], eax
; Line 83
	lea	ecx, DWORD PTR [esi+esi]
; Line 84
	mov	eax, 8192				; 00002000H
	cmp	ecx, eax
	jae	SHORT $L85049
; Line 85
	mov	ecx, eax
$L85049:
; Line 87
	call	@DiabloAllocPtr@4
	mov	edi, eax
; Line 90
	xor	eax, eax
	mov	DWORD PTR _param$[ebp+4], eax
; Line 92
	mov	DWORD PTR _param$[ebp+12], eax
; Line 95
	mov	DWORD PTR _type$[ebp], eax
; Line 97
	lea	eax, DWORD PTR _dsize$[ebp]
	push	eax
	lea	eax, DWORD PTR _type$[ebp]
	push	eax
	lea	eax, DWORD PTR _param$[ebp]
	push	eax
	mov	DWORD PTR _param$[ebp], ebx
	push	DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _param$[ebp+8], edi
	mov	DWORD PTR _param$[ebp+16], esi
	mov	DWORD PTR _dsize$[ebp], 4096		; 00001000H
	push	OFFSET FLAT:_PkwareBufferWrite
	push	OFFSET FLAT:_PkwareBufferRead
	call	_implode
	add	esp, 24					; 00000018H
; Line 99
	cmp	DWORD PTR _param$[ebp+12], esi
	jae	SHORT $L85051
; Line 100
	push	DWORD PTR _param$[ebp+12]
	push	edi
	push	ebx
	call	_memcpy
; Line 101
	mov	esi, DWORD PTR _param$[ebp+12]
	add	esp, 12					; 0000000cH
$L85051:
; Line 104
	mov	ecx, DWORD PTR _ptr$[ebp]
	call	@mem_free_dbg@4
; Line 105
	mov	ecx, edi
	call	@mem_free_dbg@4
; Line 107
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; Line 108
	leave
	ret	0
@PkwareCompress@8 ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT _PkwareBufferRead
_TEXT	SEGMENT
_buf$ = 8
_size$ = 12
_param$ = 16
_PkwareBufferRead PROC NEAR				; COMDAT
; Line 117
	mov	edx, DWORD PTR _size$[esp-4]
	push	esi
	mov	esi, DWORD PTR _param$[esp]
	push	edi
	mov	edi, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+16]
	sub	eax, ecx
	cmp	edi, eax
	jb	SHORT $L85063
; Line 118
	mov	edi, eax
$L85063:
; Line 123
	mov	eax, DWORD PTR [esi]
	push	edi
	add	eax, ecx
	push	eax
	push	DWORD PTR _buf$[esp+12]
	call	_memcpy
; Line 124
	add	DWORD PTR [esi+4], edi
	add	esp, 12					; 0000000cH
; Line 126
	mov	eax, edi
	pop	edi
	pop	esi
; Line 127
	ret	0
_PkwareBufferRead ENDP
; Function compile flags: /Ogsy
_TEXT	ENDS
;	COMDAT _PkwareBufferWrite
_TEXT	SEGMENT
_buf$ = 8
_size$ = 12
_param$ = 16
_PkwareBufferWrite PROC NEAR				; COMDAT
; Line 130
	push	esi
; Line 135
	mov	esi, DWORD PTR _param$[esp]
	push	edi
	mov	edi, DWORD PTR _size$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [edi]
	add	eax, DWORD PTR [esi+12]
	push	DWORD PTR _buf$[esp+8]
	push	eax
	call	_memcpy
; Line 136
	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [esi+12], eax
	pop	edi
	pop	esi
; Line 137
	ret	0
_PkwareBufferWrite ENDP
_TEXT	ENDS
PUBLIC	@PkwareDecompress@12
EXTRN	_explode:NEAR
; Function compile flags: /Ogsy
;	COMDAT @PkwareDecompress@12
_TEXT	SEGMENT
_dwMaxBytes$ = 8
_ptr$ = -4
_info$ = -24
@PkwareDecompress@12 PROC NEAR				; COMDAT
; _param$ = ecx
; _recv_size$ = edx
; Line 140
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; Line 145
	mov	ecx, 36312				; 00008dd8H
	mov	ebx, edx
	call	@DiabloAllocPtr@4
; Line 147
	mov	ecx, DWORD PTR _dwMaxBytes$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax
	call	@DiabloAllocPtr@4
	mov	esi, eax
; Line 155
	lea	eax, DWORD PTR _info$[ebp]
	and	DWORD PTR _info$[ebp+4], 0
	and	DWORD PTR _info$[ebp+12], 0
	push	eax
	mov	DWORD PTR _info$[ebp], edi
	push	DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _info$[ebp+8], esi
	mov	DWORD PTR _info$[ebp+16], ebx
	push	OFFSET FLAT:_PkwareBufferWrite
	push	OFFSET FLAT:_PkwareBufferRead
	call	_explode
; Line 156
	push	DWORD PTR _info$[ebp+12]
	push	esi
	push	edi
	call	_memcpy
; Line 157
	mov	ecx, DWORD PTR _ptr$[ebp]
	add	esp, 28					; 0000001cH
	call	@mem_free_dbg@4
; Line 158
	mov	ecx, esi
	call	@mem_free_dbg@4
	pop	edi
	pop	esi
	pop	ebx
; Line 159
	leave
	ret	4
@PkwareDecompress@12 ENDP
_TEXT	ENDS
END
